import{u as e,h as t,s as r}from"./vendor-rgb-CjW5GTuo.js";function n(e,t){for(var r=0;r<t.length;r++){const n=t[r];if("string"!=typeof n&&!Array.isArray(n))for(const t in n)if("default"!==t&&!(t in e)){const r=Object.getOwnPropertyDescriptor(n,t);r&&Object.defineProperty(e,t,r.get?r:{enumerable:!0,get:()=>n[t]})}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}var o={},i={},s={},a={},c={};!function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.notImplemented=t.bitMask=t.utf8ToBytes=t.randomBytes=t.isBytes=t.hexToBytes=t.concatBytes=t.bytesToUtf8=t.bytesToHex=t.anumber=t.abytes=void 0,t.abool=function(e,t){if("boolean"!=typeof t)throw new Error(e+" boolean expected, got "+t)},t._abool2=function(e,t=""){if("boolean"!=typeof e){throw new Error((t&&`"${t}"`)+"expected boolean, got type="+typeof e)}return e},t._abytes2=function(e,t,n=""){const o=(0,r.isBytes)(e),i=e?.length,s=void 0!==t;if(!o||s&&i!==t){throw new Error((n&&`"${n}" `)+"expected Uint8Array"+(s?` of length ${t}`:"")+", got "+(o?`length=${i}`:"type="+typeof e))}return e},t.numberToHexUnpadded=s,t.hexToNumber=a,t.bytesToNumberBE=function(e){return a((0,r.bytesToHex)(e))},t.bytesToNumberLE=function(e){return(0,r.abytes)(e),a((0,r.bytesToHex)(Uint8Array.from(e).reverse()))},t.numberToBytesBE=c,t.numberToBytesLE=function(e,t){return c(e,t).reverse()},t.numberToVarBytesBE=function(e){return(0,r.hexToBytes)(s(e))},t.ensureBytes=function(e,t,n){let o;if("string"==typeof t)try{o=(0,r.hexToBytes)(t)}catch(s){throw new Error(e+" must be hex string or Uint8Array, cause: "+s)}else{if(!(0,r.isBytes)(t))throw new Error(e+" must be hex string or Uint8Array");o=Uint8Array.from(t)}const i=o.length;if("number"==typeof n&&i!==n)throw new Error(e+" of length "+n+" expected, got "+i);return o},t.equalBytes=function(e,t){if(e.length!==t.length)return!1;let r=0;for(let n=0;n<e.length;n++)r|=e[n]^t[n];return 0===r},t.copyBytes=function(e){return Uint8Array.from(e)},t.asciiToBytes=function(e){return Uint8Array.from(e,(t,r)=>{const n=t.charCodeAt(0);if(1!==t.length||n>127)throw new Error(`string contains non-ASCII character "${e[r]}" with code ${n} at position ${r}`);return n})},t.inRange=f,t.aInRange=function(e,t,r,n){if(!f(t,r,n))throw new Error("expected valid "+e+": "+r+" <= n < "+n+", got "+t)},t.bitLen=function(e){let t;for(t=0;e>o;e>>=i,t+=1);return t},t.bitGet=function(e,t){return e>>BigInt(t)&i},t.bitSet=function(e,t,r){return e|(r?i:o)<<BigInt(t)},t.createHmacDrbg=function(e,t,n){if("number"!=typeof e||e<2)throw new Error("hashLen must be a number");if("number"!=typeof t||t<2)throw new Error("qByteLen must be a number");if("function"!=typeof n)throw new Error("hmacFn must be a function");const o=e=>new Uint8Array(e),i=e=>Uint8Array.of(e);let s=o(e),a=o(e),c=0;const u=()=>{s.fill(1),a.fill(0),c=0},f=(...e)=>n(a,s,...e),d=(e=o(0))=>{a=f(i(0),e),s=f(),0!==e.length&&(a=f(i(1),e),s=f())},l=()=>{if(c++>=1e3)throw new Error("drbg: tried 1000 values");let e=0;const n=[];for(;e<t;){s=f();const t=s.slice();n.push(t),e+=s.length}return(0,r.concatBytes)(...n)};return(e,t)=>{let r;for(u(),d(e);!(r=t(l()));)d();return u(),r}},t.validateObject=function(e,t,r={}){const n=(t,r,n)=>{const o=d[r];if("function"!=typeof o)throw new Error("invalid validator function");const i=e[t];if(!(n&&void 0===i||o(i,e)))throw new Error("param "+String(t)+" is invalid. Expected "+r+", got "+i)};for(const[o,i]of Object.entries(t))n(o,i,!1);for(const[o,i]of Object.entries(r))n(o,i,!0);return e},t.isHash=function(e){return"function"==typeof e&&Number.isSafeInteger(e.outputLen)},t._validateObject=function(e,t,r={}){if(!e||"object"!=typeof e)throw new Error("expected valid options object");function n(t,r,n){const o=e[t];if(n&&void 0===o)return;const i=typeof o;if(i!==r||null===o)throw new Error(`param "${t}" is invalid: expected ${r}, got ${i}`)}Object.entries(t).forEach(([e,t])=>n(e,t,!1)),Object.entries(r).forEach(([e,t])=>n(e,t,!0))},t.memoized=function(e){const t=new WeakMap;return(r,...n)=>{const o=t.get(r);if(void 0!==o)return o;const i=e(r,...n);return t.set(r,i),i}};
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const r=e;var n=e;Object.defineProperty(t,"abytes",{enumerable:!0,get:function(){return n.abytes}}),Object.defineProperty(t,"anumber",{enumerable:!0,get:function(){return n.anumber}}),Object.defineProperty(t,"bytesToHex",{enumerable:!0,get:function(){return n.bytesToHex}}),Object.defineProperty(t,"bytesToUtf8",{enumerable:!0,get:function(){return n.bytesToUtf8}}),Object.defineProperty(t,"concatBytes",{enumerable:!0,get:function(){return n.concatBytes}}),Object.defineProperty(t,"hexToBytes",{enumerable:!0,get:function(){return n.hexToBytes}}),Object.defineProperty(t,"isBytes",{enumerable:!0,get:function(){return n.isBytes}}),Object.defineProperty(t,"randomBytes",{enumerable:!0,get:function(){return n.randomBytes}}),Object.defineProperty(t,"utf8ToBytes",{enumerable:!0,get:function(){return n.utf8ToBytes}});const o=BigInt(0),i=BigInt(1);function s(e){const t=e.toString(16);return 1&t.length?"0"+t:t}function a(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);return""===e?o:BigInt("0x"+e)}function c(e,t){return(0,r.hexToBytes)(e.toString(16).padStart(2*t,"0"))}const u=e=>"bigint"==typeof e&&o<=e;function f(e,t,r){return u(e)&&u(t)&&u(r)&&t<=e&&e<r}t.bitMask=e=>(i<<BigInt(e))-i;const d={bigint:e=>"bigint"==typeof e,function:e=>"function"==typeof e,boolean:e=>"boolean"==typeof e,string:e=>"string"==typeof e,stringOrUint8Array:e=>"string"==typeof e||(0,r.isBytes)(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>"function"==typeof e&&Number.isSafeInteger(e.outputLen)};t.notImplemented=()=>{throw new Error("not implemented")}}(c);var u={},f={};Object.defineProperty(f,"__esModule",{value:!0}),f.isNegativeLE=void 0,f.mod=v,f.pow=function(e,t,r){return F(U(r),e,t)},f.pow2=function(e,t,r){let n=e;for(;t-- >l;)n*=n,n%=r;return n},f.invert=x,f.tonelliShanks=R,f.FpSqrt=I,f.validateField=function(e){const t=A.reduce((e,t)=>(e[t]="function",e),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"});return(0,d._validateObject)(e,t),e},f.FpPow=F,f.FpInvertBatch=N,f.FpDiv=function(e,t,r){return e.mul(t,"bigint"==typeof r?x(r,e.ORDER):e.inv(r))},f.FpLegendre=P,f.FpIsSquare=function(e,t){return 1===P(e,t)},f.nLength=_,f.Field=U,f.FpSqrtOdd=function(e,t){if(!e.isOdd)throw new Error("Field doesn't have isOdd");const r=e.sqrt(t);return e.isOdd(r)?r:e.neg(r)},f.FpSqrtEven=function(e,t){if(!e.isOdd)throw new Error("Field doesn't have isOdd");const r=e.sqrt(t);return e.isOdd(r)?e.neg(r):r},f.hashToPrivateScalar=function(e,t,r=!1){const n=(e=(0,d.ensureBytes)("privateHash",e)).length,o=_(t).nByteLength+8;if(o<24||n<o||n>1024)throw new Error("hashToPrivateScalar: expected "+o+"-1024 bytes of input, got "+n);return v(r?(0,d.bytesToNumberLE)(e):(0,d.bytesToNumberBE)(e),t-y)+y},f.getFieldBytesLength=q,f.getMinHashLength=k,f.mapHashToField=function(e,t,r=!1){const n=e.length,o=q(t),i=k(t);if(n<16||n<i||n>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+n);const s=v(r?(0,d.bytesToNumberLE)(e):(0,d.bytesToNumberBE)(e),t-y)+y;return r?(0,d.numberToBytesLE)(s,o):(0,d.numberToBytesBE)(s,o)};
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const d=c,l=BigInt(0),y=BigInt(1),h=BigInt(2),b=BigInt(3),m=BigInt(4),p=BigInt(5),w=BigInt(7),g=BigInt(8),E=BigInt(9),B=BigInt(16);function v(e,t){const r=e%t;return r>=l?r:t+r}function x(e,t){if(e===l)throw new Error("invert: expected non-zero number");if(t<=l)throw new Error("invert: expected positive modulus, got "+t);let r=v(e,t),n=t,o=l,i=y;for(;r!==l;){const e=n%r,t=o-i*(n/r);n=r,r=e,o=i,i=t}if(n!==y)throw new Error("invert: does not exist");return v(o,t)}function O(e,t,r){if(!e.eql(e.sqr(t),r))throw new Error("Cannot find square root")}function T(e,t){const r=(e.ORDER+y)/m,n=e.pow(t,r);return O(e,n,t),n}function S(e,t){const r=(e.ORDER-p)/g,n=e.mul(t,h),o=e.pow(n,r),i=e.mul(t,o),s=e.mul(e.mul(i,h),o),a=e.mul(i,e.sub(s,e.ONE));return O(e,a,t),a}function R(e){if(e<b)throw new Error("sqrt is not defined for small field");let t=e-y,r=0;for(;t%h===l;)t/=h,r++;let n=h;const o=U(e);for(;1===P(o,n);)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(1===r)return T;let i=o.pow(n,t);const s=(t+y)/h;return function(e,n){if(e.is0(n))return n;if(1!==P(e,n))throw new Error("Cannot find square root");let o=r,a=e.mul(e.ONE,i),c=e.pow(n,t),u=e.pow(n,s);for(;!e.eql(c,e.ONE);){if(e.is0(c))return e.ZERO;let t=1,r=e.sqr(c);for(;!e.eql(r,e.ONE);)if(t++,r=e.sqr(r),t===o)throw new Error("Cannot find square root");const n=y<<BigInt(o-t-1),i=e.pow(a,n);o=t,a=e.sqr(i),c=e.mul(c,a),u=e.mul(u,i)}return u}}function I(e){return e%m===b?T:e%g===p?S:e%B===E?function(e){const t=U(e),r=R(e),n=r(t,t.neg(t.ONE)),o=r(t,n),i=r(t,t.neg(n)),s=(e+w)/B;return(e,t)=>{let r=e.pow(t,s),a=e.mul(r,n);const c=e.mul(r,o),u=e.mul(r,i),f=e.eql(e.sqr(a),t),d=e.eql(e.sqr(c),t);r=e.cmov(r,a,f),a=e.cmov(u,c,d);const l=e.eql(e.sqr(a),t),y=e.cmov(r,a,l);return O(e,y,t),y}}(e):R(e)}f.isNegativeLE=(e,t)=>(v(e,t)&y)===y;const A=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function F(e,t,r){if(r<l)throw new Error("invalid exponent, negatives unsupported");if(r===l)return e.ONE;if(r===y)return t;let n=e.ONE,o=t;for(;r>l;)r&y&&(n=e.mul(n,o)),o=e.sqr(o),r>>=y;return n}function N(e,t,r=!1){const n=new Array(t.length).fill(r?e.ZERO:void 0),o=t.reduce((t,r,o)=>e.is0(r)?t:(n[o]=t,e.mul(t,r)),e.ONE),i=e.inv(o);return t.reduceRight((t,r,o)=>e.is0(r)?t:(n[o]=e.mul(t,n[o]),e.mul(t,r)),i),n}function P(e,t){const r=(e.ORDER-y)/h,n=e.pow(t,r),o=e.eql(n,e.ONE),i=e.eql(n,e.ZERO),s=e.eql(n,e.neg(e.ONE));if(!o&&!i&&!s)throw new Error("invalid Legendre symbol result");return o?1:i?0:-1}function _(e,t){void 0!==t&&(0,d.anumber)(t);const r=void 0!==t?t:e.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function U(e,t,r=!1,n={}){if(e<=l)throw new Error("invalid field: expected ORDER > 0, got "+e);let o,i,s,a=!1;if("object"==typeof t&&null!=t){if(n.sqrt||r)throw new Error("cannot specify opts in two arguments");const e=t;e.BITS&&(o=e.BITS),e.sqrt&&(i=e.sqrt),"boolean"==typeof e.isLE&&(r=e.isLE),"boolean"==typeof e.modFromBytes&&(a=e.modFromBytes),s=e.allowedLengths}else"number"==typeof t&&(o=t),n.sqrt&&(i=n.sqrt);const{nBitLength:c,nByteLength:u}=_(e,o);if(u>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let f;const h=Object.freeze({ORDER:e,isLE:r,BITS:c,BYTES:u,MASK:(0,d.bitMask)(c),ZERO:l,ONE:y,allowedLengths:s,create:t=>v(t,e),isValid:t=>{if("bigint"!=typeof t)throw new Error("invalid field element: expected bigint, got "+typeof t);return l<=t&&t<e},is0:e=>e===l,isValidNot0:e=>!h.is0(e)&&h.isValid(e),isOdd:e=>(e&y)===y,neg:t=>v(-t,e),eql:(e,t)=>e===t,sqr:t=>v(t*t,e),add:(t,r)=>v(t+r,e),sub:(t,r)=>v(t-r,e),mul:(t,r)=>v(t*r,e),pow:(e,t)=>F(h,e,t),div:(t,r)=>v(t*x(r,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>x(t,e),sqrt:i||(t=>(f||(f=I(e)),f(h,t))),toBytes:e=>r?(0,d.numberToBytesLE)(e,u):(0,d.numberToBytesBE)(e,u),fromBytes:(t,n=!0)=>{if(s){if(!s.includes(t.length)||t.length>u)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+t.length);const e=new Uint8Array(u);e.set(t,r?0:e.length-t.length),t=e}if(t.length!==u)throw new Error("Field.fromBytes: expected "+u+" bytes, got "+t.length);let o=r?(0,d.bytesToNumberLE)(t):(0,d.bytesToNumberBE)(t);if(a&&(o=v(o,e)),!n&&!h.isValid(o))throw new Error("invalid field element: outside of range 0..ORDER");return o},invertBatch:e=>N(h,e),cmov:(e,t,r)=>r?t:e});return Object.freeze(h)}function q(e){if("bigint"!=typeof e)throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function k(e){const t=q(e);return t+Math.ceil(t/2)}Object.defineProperty(u,"__esModule",{value:!0}),u.wNAF=void 0,u.negateCt=V,u.normalizeZ=function(e,t){const r=(0,C.FpInvertBatch)(e.Fp,t.map(e=>e.Z));return t.map((t,n)=>e.fromAffine(t.toAffine(r[n])))},u.mulEndoUnsafe=function(e,t,r,n){let o=t,i=e.ZERO,s=e.ZERO;for(;r>D||n>D;)r&H&&(i=i.add(o)),n&H&&(s=s.add(o)),o=o.double(),r>>=H,n>>=H;return{p1:i,p2:s}},u.pippenger=function(e,t,r,n){M(r,e),z(n,t);const o=r.length,i=n.length;if(o!==i)throw new Error("arrays of points and scalars must have equal length");const s=e.ZERO,a=(0,j.bitLen)(BigInt(o));let c=1;a>12?c=a-3:a>4?c=a-2:a>0&&(c=2);const u=(0,j.bitMask)(c),f=new Array(Number(u)+1).fill(s),d=Math.floor((t.BITS-1)/c)*c;let l=s;for(let y=d;y>=0;y-=c){f.fill(s);for(let t=0;t<i;t++){const e=n[t],o=Number(e>>BigInt(y)&u);f[o]=f[o].add(r[t])}let e=s;for(let t=f.length-1,r=s;t>0;t--)r=r.add(f[t]),e=e.add(r);if(l=l.add(e),0!==y)for(let t=0;t<c;t++)l=l.double()}return l},u.precomputeMSMUnsafe=function(e,t,r,n){L(n,t.BITS),M(r,e);const o=e.ZERO,i=2**n-1,s=Math.ceil(t.BITS/n),a=(0,j.bitMask)(n),c=r.map(e=>{const t=[];for(let r=0,n=e;r<i;r++)t.push(n),n=n.add(e);return t});return e=>{if(z(e,t),e.length>r.length)throw new Error("array of scalars must be smaller than array of points");let i=o;for(let t=0;t<s;t++){if(i!==o)for(let e=0;e<n;e++)i=i.double();const r=BigInt(s*n-(t+1)*n);for(let t=0;t<e.length;t++){const n=e[t],o=Number(n>>r&a);o&&(i=i.add(c[t][o-1]))}}return i}},u.validateBasic=function(e){return(0,C.validateField)(e.Fp),(0,j.validateObject)(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...(0,C.nLength)(e.n,e.nBitLength),...e,p:e.Fp.ORDER})},u._createCurveFields=function(e,t,r={},n){void 0===n&&(n="edwards"===e);if(!t||"object"!=typeof t)throw new Error(`expected valid ${e} CURVE object`);for(const a of["p","n","h"]){const e=t[a];if(!("bigint"==typeof e&&e>D))throw new Error(`CURVE.${a} must be positive bigint`)}const o=W(t.p,r.Fp,n),i=W(t.n,r.Fn,n),s=["Gx","Gy","a","weierstrass"===e?"b":"d"];for(const a of s)if(!o.isValid(t[a]))throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);return{CURVE:t=Object.freeze(Object.assign({},t)),Fp:o,Fn:i}};
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const j=c,C=f,D=BigInt(0),H=BigInt(1);function V(e,t){const r=t.negate();return e?r:t}function L(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+e)}function Z(e,t){L(e,t);const r=2**e;return{windows:Math.ceil(t/e)+1,windowSize:2**(e-1),mask:(0,j.bitMask)(e),maxNumber:r,shiftBy:BigInt(e)}}function K(e,t,r){const{windowSize:n,mask:o,maxNumber:i,shiftBy:s}=r;let a=Number(e&o),c=e>>s;a>n&&(a-=i,c+=H);const u=t*n;return{nextN:c,offset:u+Math.abs(a)-1,isZero:0===a,isNeg:a<0,isNegF:t%2!=0,offsetF:u}}function M(e,t){if(!Array.isArray(e))throw new Error("array expected");e.forEach((e,r)=>{if(!(e instanceof t))throw new Error("invalid point at index "+r)})}function z(e,t){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((e,r)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+r)})}const $=new WeakMap,Y=new WeakMap;function G(e){return Y.get(e)||1}function X(e){if(e!==D)throw new Error("invalid wNAF")}function W(e,t,r){if(t){if(t.ORDER!==e)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return(0,C.validateField)(t),t}return(0,C.Field)(e,{isLE:r})}u.wNAF=class{constructor(e,t){this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=t}_unsafeLadder(e,t,r=this.ZERO){let n=e;for(;t>D;)t&H&&(r=r.add(n)),n=n.double(),t>>=H;return r}precomputeWindow(e,t){const{windows:r,windowSize:n}=Z(t,this.bits),o=[];let i=e,s=i;for(let a=0;a<r;a++){s=i,o.push(s);for(let e=1;e<n;e++)s=s.add(i),o.push(s);i=s.double()}return o}wNAF(e,t,r){if(!this.Fn.isValid(r))throw new Error("invalid scalar");let n=this.ZERO,o=this.BASE;const i=Z(e,this.bits);for(let s=0;s<i.windows;s++){const{nextN:e,offset:a,isZero:c,isNeg:u,isNegF:f,offsetF:d}=K(r,s,i);r=e,c?o=o.add(V(f,t[d])):n=n.add(V(u,t[a]))}return X(r),{p:n,f:o}}wNAFUnsafe(e,t,r,n=this.ZERO){const o=Z(e,this.bits);for(let i=0;i<o.windows&&r!==D;i++){const{nextN:e,offset:s,isZero:a,isNeg:c}=K(r,i,o);if(r=e,!a){const e=t[s];n=n.add(c?e.negate():e)}}return X(r),n}getPrecomputes(e,t,r){let n=$.get(t);return n||(n=this.precomputeWindow(t,e),1!==e&&("function"==typeof r&&(n=r(n)),$.set(t,n))),n}cached(e,t,r){const n=G(e);return this.wNAF(n,this.getPrecomputes(n,e,r),t)}unsafe(e,t,r,n){const o=G(e);return 1===o?this._unsafeLadder(e,t,n):this.wNAFUnsafe(o,this.getPrecomputes(o,e,r),t,n)}createCache(e,t){L(t,this.bits),Y.set(e,t),$.delete(e)}hasCache(e){return 1!==G(e)}},function(r){Object.defineProperty(r,"__esModule",{value:!0}),r.DER=r.DERErr=void 0,r._splitEndoScalar=l,r._normFnElement=B,r.weierstrassN=v,r.SWUFpSqrtRatio=O,r.mapToCurveSimpleSWU=function(e,t){(0,a.validateField)(e);const{A:r,B:n,Z:o}=t;if(!e.isValid(r)||!e.isValid(n)||!e.isValid(o))throw new Error("mapToCurveSimpleSWU: invalid opts");const i=O(e,o);if(!e.isOdd)throw new Error("Field does not have .isOdd()");return t=>{let s,c,u,f,d,l,y,h;s=e.sqr(t),s=e.mul(s,o),c=e.sqr(s),c=e.add(c,s),u=e.add(c,e.ONE),u=e.mul(u,n),f=e.cmov(o,e.neg(c),!e.eql(c,e.ZERO)),f=e.mul(f,r),c=e.sqr(u),l=e.sqr(f),d=e.mul(l,r),c=e.add(c,d),c=e.mul(c,u),l=e.mul(l,f),d=e.mul(l,n),c=e.add(c,d),y=e.mul(s,u);const{isValid:b,value:m}=i(c,l);h=e.mul(s,t),h=e.mul(h,m),y=e.cmov(y,u,b),h=e.cmov(h,m,b);const p=e.isOdd(t)===e.isOdd(h);h=e.cmov(e.neg(h),h,p);const w=(0,a.FpInvertBatch)(e,[f],!0)[0];return y=e.mul(y,w),{x:y,y:h}}},r.ecdh=S,r.ecdsa=R,r.weierstrassPoints=function(e){const{CURVE:t,curveOpts:r}=I(e),n=v(t,r);return function(e,t){const{Fp:r,Fn:n}=t;function o(e){return(0,i.inRange)(e,p,n.ORDER)}const s=A(r,e.a,e.b);return Object.assign({},{CURVE:e,Point:t,ProjectivePoint:t,normPrivateKeyToScalar:e=>B(n,e),weierstrassEquation:s,isWithinCurveOrder:o})}(e,n)},r._legacyHelperEquat=A,r.weierstrass=function(e){const{CURVE:t,curveOpts:r,hash:n,ecdsaOpts:o}=function(e){const{CURVE:t,curveOpts:r}=I(e),n={hmac:e.hmac,randomBytes:e.randomBytes,lowS:e.lowS,bits2int:e.bits2int,bits2int_modN:e.bits2int_modN};return{CURVE:t,curveOpts:r,hash:e.hash,ecdsaOpts:n}}(e),i=v(t,r),s=R(i,n,o);return function(e,t){const r=t.Point;return Object.assign({},t,{ProjectivePoint:r,CURVE:Object.assign({},e,(0,a.nLength)(r.Fn.ORDER,r.Fn.BITS))})}(e,s)};
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const n=t,o=e,i=c,s=u,a=f,d=(e,t)=>(e+(e>=0?t:-t)/w)/t;function l(e,t,r){const[[n,o],[s,a]]=t,c=d(a*e,r),u=d(-o*e,r);let f=e-c*n-u*s,l=-c*o-u*a;const y=f<m,h=l<m;y&&(f=-f),h&&(l=-l);const b=(0,i.bitMask)(Math.ceil((0,i.bitLen)(r)/2))+p;if(f<m||f>=b||l<m||l>=b)throw new Error("splitScalar (endomorphism): failed, k="+e);return{k1neg:y,k1:f,k2neg:h,k2:l}}function y(e){if(!["compact","recovered","der"].includes(e))throw new Error('Signature format must be "compact", "recovered", or "der"');return e}function h(e,t){const r={};for(let n of Object.keys(t))r[n]=void 0===e[n]?t[n]:e[n];return(0,i._abool2)(r.lowS,"lowS"),(0,i._abool2)(r.prehash,"prehash"),void 0!==r.format&&y(r.format),r}class b extends Error{constructor(e=""){super(e)}}r.DERErr=b,r.DER={Err:b,_tlv:{encode:(e,t)=>{const{Err:n}=r.DER;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(1&t.length)throw new n("tlv.encode: unpadded data");const o=t.length/2,s=(0,i.numberToHexUnpadded)(o);if(s.length/2&128)throw new n("tlv.encode: long form length too big");const a=o>127?(0,i.numberToHexUnpadded)(s.length/2|128):"";return(0,i.numberToHexUnpadded)(e)+a+s+t},decode(e,t){const{Err:n}=r.DER;let o=0;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(t.length<2||t[o++]!==e)throw new n("tlv.decode: wrong tlv");const i=t[o++];let s=0;if(!!(128&i)){const e=127&i;if(!e)throw new n("tlv.decode(long): indefinite length not supported");if(e>4)throw new n("tlv.decode(long): byte length is too big");const r=t.subarray(o,o+e);if(r.length!==e)throw new n("tlv.decode: length bytes not complete");if(0===r[0])throw new n("tlv.decode(long): zero leftmost byte");for(const t of r)s=s<<8|t;if(o+=e,s<128)throw new n("tlv.decode(long): not minimal encoding")}else s=i;const a=t.subarray(o,o+s);if(a.length!==s)throw new n("tlv.decode: wrong value length");return{v:a,l:t.subarray(o+s)}}},_int:{encode(e){const{Err:t}=r.DER;if(e<m)throw new t("integer: negative integers are not allowed");let n=(0,i.numberToHexUnpadded)(e);if(8&Number.parseInt(n[0],16)&&(n="00"+n),1&n.length)throw new t("unexpected DER parsing assertion: unpadded hex");return n},decode(e){const{Err:t}=r.DER;if(128&e[0])throw new t("invalid signature integer: negative");if(0===e[0]&&!(128&e[1]))throw new t("invalid signature integer: unnecessary leading zero");return(0,i.bytesToNumberBE)(e)}},toSig(e){const{Err:t,_int:n,_tlv:o}=r.DER,s=(0,i.ensureBytes)("signature",e),{v:a,l:c}=o.decode(48,s);if(c.length)throw new t("invalid signature: left bytes after parsing");const{v:u,l:f}=o.decode(2,a),{v:d,l:l}=o.decode(2,f);if(l.length)throw new t("invalid signature: left bytes after parsing");return{r:n.decode(u),s:n.decode(d)}},hexFromSig(e){const{_tlv:t,_int:n}=r.DER,o=t.encode(2,n.encode(e.r))+t.encode(2,n.encode(e.s));return t.encode(48,o)}};const m=BigInt(0),p=BigInt(1),w=BigInt(2),g=BigInt(3),E=BigInt(4);function B(e,t){const{BYTES:r}=e;let n;if("bigint"==typeof t)n=t;else{let s=(0,i.ensureBytes)("private key",t);try{n=e.fromBytes(s)}catch(o){throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof t}`)}}if(!e.isValidNot0(n))throw new Error("invalid private key: out of range [1..N-1]");return n}function v(e,t={}){const r=(0,s._createCurveFields)("weierstrass",e,t),{Fp:n,Fn:o}=r;let a=r.CURVE;const{h:c,n:u}=a;(0,i._validateObject)(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:f}=t;if(f&&(!n.is0(a.a)||"bigint"!=typeof f.beta||!Array.isArray(f.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const d=T(n,o);function y(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}const h=t.toBytes||function(e,t,r){const{x:o,y:s}=t.toAffine(),a=n.toBytes(o);if((0,i._abool2)(r,"isCompressed"),r){y();const e=!n.isOdd(s);return(0,i.concatBytes)(x(e),a)}return(0,i.concatBytes)(Uint8Array.of(4),a,n.toBytes(s))},b=t.fromBytes||function(e){(0,i._abytes2)(e,void 0,"Point");const{publicKey:t,publicKeyUncompressed:r}=d,o=e.length,s=e[0],a=e.subarray(1);if(o!==t||2!==s&&3!==s){if(o===r&&4===s){const e=n.BYTES,t=n.fromBytes(a.subarray(0,e)),r=n.fromBytes(a.subarray(e,2*e));if(!v(t,r))throw new Error("bad point: is not on curve");return{x:t,y:r}}throw new Error(`bad point: got length ${o}, expected compressed=${t} or uncompressed=${r}`)}{const e=n.fromBytes(a);if(!n.isValid(e))throw new Error("bad point: is not on curve, wrong x");const t=w(e);let r;try{r=n.sqrt(t)}catch(c){const e=c instanceof Error?": "+c.message:"";throw new Error("bad point: is not on curve, sqrt error"+e)}y();return!(1&~s)!==n.isOdd(r)&&(r=n.neg(r)),{x:e,y:r}}};function w(e){const t=n.sqr(e),r=n.mul(t,e);return n.add(n.add(r,n.mul(e,a.a)),a.b)}function v(e,t){const r=n.sqr(t),o=w(e);return n.eql(r,o)}if(!v(a.Gx,a.Gy))throw new Error("bad curve params: generator point");const O=n.mul(n.pow(a.a,g),E),S=n.mul(n.sqr(a.b),BigInt(27));if(n.is0(n.add(O,S)))throw new Error("bad curve params: a or b");function R(e,t,r=!1){if(!n.isValid(t)||r&&n.is0(t))throw new Error(`bad point coordinate ${e}`);return t}function I(e){if(!(e instanceof _))throw new Error("ProjectivePoint expected")}function A(e){if(!f||!f.basises)throw new Error("no endo");return l(e,f.basises,o.ORDER)}const F=(0,i.memoized)((e,t)=>{const{X:r,Y:o,Z:i}=e;if(n.eql(i,n.ONE))return{x:r,y:o};const s=e.is0();null==t&&(t=s?n.ONE:n.inv(i));const a=n.mul(r,t),c=n.mul(o,t),u=n.mul(i,t);if(s)return{x:n.ZERO,y:n.ZERO};if(!n.eql(u,n.ONE))throw new Error("invZ was invalid");return{x:a,y:c}}),N=(0,i.memoized)(e=>{if(e.is0()){if(t.allowInfinityPoint&&!n.is0(e.Y))return;throw new Error("bad point: ZERO")}const{x:r,y:o}=e.toAffine();if(!n.isValid(r)||!n.isValid(o))throw new Error("bad point: x or y not field elements");if(!v(r,o))throw new Error("bad point: equation left != right");if(!e.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function P(e,t,r,o,i){return r=new _(n.mul(r.X,e),r.Y,r.Z),t=(0,s.negateCt)(o,t),r=(0,s.negateCt)(i,r),t.add(r)}class _{constructor(e,t,r){this.X=R("x",e),this.Y=R("y",t,!0),this.Z=R("z",r),Object.freeze(this)}static CURVE(){return a}static fromAffine(e){const{x:t,y:r}=e||{};if(!e||!n.isValid(t)||!n.isValid(r))throw new Error("invalid affine point");if(e instanceof _)throw new Error("projective point not allowed");return n.is0(t)&&n.is0(r)?_.ZERO:new _(t,r,n.ONE)}static fromBytes(e){const t=_.fromAffine(b((0,i._abytes2)(e,void 0,"point")));return t.assertValidity(),t}static fromHex(e){return _.fromBytes((0,i.ensureBytes)("pointHex",e))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(e=8,t=!0){return q.createCache(this,e),t||this.multiply(g),this}assertValidity(){N(this)}hasEvenY(){const{y:e}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(e)}equals(e){I(e);const{X:t,Y:r,Z:o}=this,{X:i,Y:s,Z:a}=e,c=n.eql(n.mul(t,a),n.mul(i,o)),u=n.eql(n.mul(r,a),n.mul(s,o));return c&&u}negate(){return new _(this.X,n.neg(this.Y),this.Z)}double(){const{a:e,b:t}=a,r=n.mul(t,g),{X:o,Y:i,Z:s}=this;let c=n.ZERO,u=n.ZERO,f=n.ZERO,d=n.mul(o,o),l=n.mul(i,i),y=n.mul(s,s),h=n.mul(o,i);return h=n.add(h,h),f=n.mul(o,s),f=n.add(f,f),c=n.mul(e,f),u=n.mul(r,y),u=n.add(c,u),c=n.sub(l,u),u=n.add(l,u),u=n.mul(c,u),c=n.mul(h,c),f=n.mul(r,f),y=n.mul(e,y),h=n.sub(d,y),h=n.mul(e,h),h=n.add(h,f),f=n.add(d,d),d=n.add(f,d),d=n.add(d,y),d=n.mul(d,h),u=n.add(u,d),y=n.mul(i,s),y=n.add(y,y),d=n.mul(y,h),c=n.sub(c,d),f=n.mul(y,l),f=n.add(f,f),f=n.add(f,f),new _(c,u,f)}add(e){I(e);const{X:t,Y:r,Z:o}=this,{X:i,Y:s,Z:c}=e;let u=n.ZERO,f=n.ZERO,d=n.ZERO;const l=a.a,y=n.mul(a.b,g);let h=n.mul(t,i),b=n.mul(r,s),m=n.mul(o,c),p=n.add(t,r),w=n.add(i,s);p=n.mul(p,w),w=n.add(h,b),p=n.sub(p,w),w=n.add(t,o);let E=n.add(i,c);return w=n.mul(w,E),E=n.add(h,m),w=n.sub(w,E),E=n.add(r,o),u=n.add(s,c),E=n.mul(E,u),u=n.add(b,m),E=n.sub(E,u),d=n.mul(l,w),u=n.mul(y,m),d=n.add(u,d),u=n.sub(b,d),d=n.add(b,d),f=n.mul(u,d),b=n.add(h,h),b=n.add(b,h),m=n.mul(l,m),w=n.mul(y,w),b=n.add(b,m),m=n.sub(h,m),m=n.mul(l,m),w=n.add(w,m),h=n.mul(b,w),f=n.add(f,h),h=n.mul(E,w),u=n.mul(p,u),u=n.sub(u,h),h=n.mul(p,b),d=n.mul(E,d),d=n.add(d,h),new _(u,f,d)}subtract(e){return this.add(e.negate())}is0(){return this.equals(_.ZERO)}multiply(e){const{endo:r}=t;if(!o.isValidNot0(e))throw new Error("invalid scalar: out of range");let n,i;const a=e=>q.cached(this,e,e=>(0,s.normalizeZ)(_,e));if(r){const{k1neg:t,k1:o,k2neg:s,k2:c}=A(e),{p:u,f:f}=a(o),{p:d,f:l}=a(c);i=f.add(l),n=P(r.beta,u,d,t,s)}else{const{p:t,f:r}=a(e);n=t,i=r}return(0,s.normalizeZ)(_,[n,i])[0]}multiplyUnsafe(e){const{endo:r}=t,n=this;if(!o.isValid(e))throw new Error("invalid scalar: out of range");if(e===m||n.is0())return _.ZERO;if(e===p)return n;if(q.hasCache(this))return this.multiply(e);if(r){const{k1neg:t,k1:o,k2neg:i,k2:a}=A(e),{p1:c,p2:u}=(0,s.mulEndoUnsafe)(_,n,o,a);return P(r.beta,c,u,t,i)}return q.unsafe(n,e)}multiplyAndAddUnsafe(e,t,r){const n=this.multiplyUnsafe(t).add(e.multiplyUnsafe(r));return n.is0()?void 0:n}toAffine(e){return F(this,e)}isTorsionFree(){const{isTorsionFree:e}=t;return c===p||(e?e(_,this):q.unsafe(this,u).is0())}clearCofactor(){const{clearCofactor:e}=t;return c===p?this:e?e(_,this):this.multiplyUnsafe(c)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}toBytes(e=!0){return(0,i._abool2)(e,"isCompressed"),this.assertValidity(),h(_,this,e)}toHex(e=!0){return(0,i.bytesToHex)(this.toBytes(e))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(e=!0){return this.toBytes(e)}_setWindowSize(e){this.precompute(e)}static normalizeZ(e){return(0,s.normalizeZ)(_,e)}static msm(e,t){return(0,s.pippenger)(_,o,e,t)}static fromPrivateKey(e){return _.BASE.multiply(B(o,e))}}_.BASE=new _(a.Gx,a.Gy,n.ONE),_.ZERO=new _(n.ZERO,n.ONE,n.ZERO),_.Fp=n,_.Fn=o;const U=o.BITS,q=new s.wNAF(_,t.endo?Math.ceil(U/2):U);return _.BASE.precompute(8),_}function x(e){return Uint8Array.of(e?2:3)}function O(e,t){const r=e.ORDER;let n=m;for(let h=r-p;h%w===m;h/=w)n+=p;const o=n,i=w<<o-p-p,s=i*w,a=(r-p)/s,c=(a-p)/w,u=s-p,f=i,d=e.pow(t,a),l=e.pow(t,(a+p)/w);let y=(t,r)=>{let n=d,i=e.pow(r,u),s=e.sqr(i);s=e.mul(s,r);let a=e.mul(t,s);a=e.pow(a,c),a=e.mul(a,i),i=e.mul(a,r),s=e.mul(a,t);let y=e.mul(s,i);a=e.pow(y,f);let h=e.eql(a,e.ONE);i=e.mul(s,l),a=e.mul(y,n),s=e.cmov(i,s,h),y=e.cmov(a,y,h);for(let c=o;c>p;c--){let t=c-w;t=w<<t-p;let r=e.pow(y,t);const o=e.eql(r,e.ONE);i=e.mul(s,n),n=e.mul(n,n),r=e.mul(y,n),s=e.cmov(i,s,o),y=e.cmov(r,y,o)}return{isValid:h,value:s}};if(e.ORDER%E===g){const r=(e.ORDER-g)/E,n=e.sqrt(e.neg(t));y=(t,o)=>{let i=e.sqr(o);const s=e.mul(t,o);i=e.mul(i,s);let a=e.pow(i,r);a=e.mul(a,s);const c=e.mul(a,n),u=e.mul(e.sqr(a),o),f=e.eql(u,t);return{isValid:f,value:e.cmov(c,a,f)}}}return y}function T(e,t){return{secretKey:t.BYTES,publicKey:1+e.BYTES,publicKeyUncompressed:1+2*e.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function S(e,t={}){const{Fn:r}=e,n=t.randomBytes||i.randomBytes,o=Object.assign(T(e.Fp,r),{seed:(0,a.getMinHashLength)(r.ORDER)});function s(e){try{return!!B(r,e)}catch(t){return!1}}function c(e=n(o.seed)){return(0,a.mapHashToField)((0,i._abytes2)(e,o.seed,"seed"),r.ORDER)}function u(t,n=!0){return e.BASE.multiply(B(r,t)).toBytes(n)}function f(t){if("bigint"==typeof t)return!1;if(t instanceof e)return!0;const{secretKey:n,publicKey:s,publicKeyUncompressed:a}=o;if(r.allowedLengths||n===s)return;const c=(0,i.ensureBytes)("key",t).length;return c===s||c===a}const d={isValidSecretKey:s,isValidPublicKey:function(t,r){const{publicKey:n,publicKeyUncompressed:i}=o;try{const o=t.length;return(!0!==r||o===n)&&((!1!==r||o===i)&&!!e.fromBytes(t))}catch(s){return!1}},randomSecretKey:c,isValidPrivateKey:s,randomPrivateKey:c,normPrivateKeyToScalar:e=>B(r,e),precompute:(t=8,r=e.BASE)=>r.precompute(t,!1)};return Object.freeze({getPublicKey:u,getSharedSecret:function(t,n,o=!0){if(!0===f(t))throw new Error("first arg must be private key");if(!1===f(n))throw new Error("second arg must be public key");const i=B(r,t);return e.fromHex(n).multiply(i).toBytes(o)},keygen:function(e){const t=c(e);return{secretKey:t,publicKey:u(t)}},Point:e,utils:d,lengths:o})}function R(e,t,s={}){(0,o.ahash)(t),(0,i._validateObject)(s,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const a=s.randomBytes||i.randomBytes,c=s.hmac||((e,...r)=>(0,n.hmac)(t,e,(0,i.concatBytes)(...r))),{Fp:u,Fn:f}=e,{ORDER:d,BITS:l}=f,{keygen:b,getPublicKey:g,getSharedSecret:E,utils:v,lengths:O}=S(e,s),T={prehash:!1,lowS:"boolean"==typeof s.lowS&&s.lowS,format:void 0,extraEntropy:!1},R="compact";function I(e){return e>d>>p}function A(e,t){if(!f.isValidNot0(t))throw new Error(`invalid signature ${e}: out of range 1..Point.Fn.ORDER`);return t}class F{constructor(e,t,r){this.r=A("r",e),this.s=A("s",t),null!=r&&(this.recovery=r),Object.freeze(this)}static fromBytes(e,t=R){let n;if(function(e,t){y(t);const r=O.signature,n="compact"===t?r:"recovered"===t?r+1:void 0;(0,i._abytes2)(e,n,`${t} signature`)}(e,t),"der"===t){const{r:t,s:n}=r.DER.toSig((0,i._abytes2)(e));return new F(t,n)}"recovered"===t&&(n=e[0],t="compact",e=e.subarray(1));const o=f.BYTES,s=e.subarray(0,o),a=e.subarray(o,2*o);return new F(f.fromBytes(s),f.fromBytes(a),n)}static fromHex(e,t){return this.fromBytes((0,i.hexToBytes)(e),t)}addRecoveryBit(e){return new F(this.r,this.s,e)}recoverPublicKey(t){const r=u.ORDER,{r:n,s:o,recovery:s}=this;if(null==s||![0,1,2,3].includes(s))throw new Error("recovery id invalid");if(d*w<r&&s>1)throw new Error("recovery id is ambiguous for h>1 curve");const a=2===s||3===s?n+d:n;if(!u.isValid(a))throw new Error("recovery id 2 or 3 invalid");const c=u.toBytes(a),l=e.fromBytes((0,i.concatBytes)(x(!(1&s)),c)),y=f.inv(a),h=P((0,i.ensureBytes)("msgHash",t)),b=f.create(-h*y),m=f.create(o*y),p=e.BASE.multiplyUnsafe(b).add(l.multiplyUnsafe(m));if(p.is0())throw new Error("point at infinify");return p.assertValidity(),p}hasHighS(){return I(this.s)}toBytes(e=R){if(y(e),"der"===e)return(0,i.hexToBytes)(r.DER.hexFromSig(this));const t=f.toBytes(this.r),n=f.toBytes(this.s);if("recovered"===e){if(null==this.recovery)throw new Error("recovery bit must be present");return(0,i.concatBytes)(Uint8Array.of(this.recovery),t,n)}return(0,i.concatBytes)(t,n)}toHex(e){return(0,i.bytesToHex)(this.toBytes(e))}assertValidity(){}static fromCompact(e){return F.fromBytes((0,i.ensureBytes)("sig",e),"compact")}static fromDER(e){return F.fromBytes((0,i.ensureBytes)("sig",e),"der")}normalizeS(){return this.hasHighS()?new F(this.r,f.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return(0,i.bytesToHex)(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return(0,i.bytesToHex)(this.toBytes("compact"))}}const N=s.bits2int||function(e){if(e.length>8192)throw new Error("input is too large");const t=(0,i.bytesToNumberBE)(e),r=8*e.length-l;return r>0?t>>BigInt(r):t},P=s.bits2int_modN||function(e){return f.create(N(e))},_=(0,i.bitMask)(l);function U(e){return(0,i.aInRange)("num < 2^"+l,e,m,_),f.toBytes(e)}function q(e,r){return(0,i._abytes2)(e,void 0,"message"),r?(0,i._abytes2)(t(e),void 0,"prehashed message"):e}return Object.freeze({keygen:b,getPublicKey:g,getSharedSecret:E,utils:v,lengths:O,Point:e,sign:function(r,n,o={}){r=(0,i.ensureBytes)("message",r);const{seed:s,k2sig:u}=function(t,r,n){if(["recovered","canonical"].some(e=>e in n))throw new Error("sign() legacy options not supported");const{lowS:o,prehash:s,extraEntropy:c}=h(n,T);t=q(t,s);const u=P(t),d=B(f,r),l=[U(d),U(u)];if(null!=c&&!1!==c){const e=!0===c?a(O.secretKey):c;l.push((0,i.ensureBytes)("extraEntropy",e))}const y=(0,i.concatBytes)(...l),b=u;return{seed:y,k2sig:function(t){const r=N(t);if(!f.isValidNot0(r))return;const n=f.inv(r),i=e.BASE.multiply(r).toAffine(),s=f.create(i.x);if(s===m)return;const a=f.create(n*f.create(b+s*d));if(a===m)return;let c=(i.x===s?0:2)|Number(i.y&p),u=a;return o&&I(a)&&(u=f.neg(a),c^=1),new F(s,u,c)}}}(r,n,o);return(0,i.createHmacDrbg)(t.outputLen,f.BYTES,c)(s,u)},verify:function(t,n,o,s={}){const{lowS:a,prehash:c,format:u}=h(s,T);if(o=(0,i.ensureBytes)("publicKey",o),n=q((0,i.ensureBytes)("message",n),c),"strict"in s)throw new Error("options.strict was renamed to lowS");const d=void 0===u?function(e){let t;const n="string"==typeof e||(0,i.isBytes)(e),o=!n&&null!==e&&"object"==typeof e&&"bigint"==typeof e.r&&"bigint"==typeof e.s;if(!n&&!o)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(o)t=new F(e.r,e.s);else if(n){try{t=F.fromBytes((0,i.ensureBytes)("sig",e),"der")}catch(s){if(!(s instanceof r.DER.Err))throw s}if(!t)try{t=F.fromBytes((0,i.ensureBytes)("sig",e),"compact")}catch(a){return!1}}return t||!1}(t):F.fromBytes((0,i.ensureBytes)("sig",t),u);if(!1===d)return!1;try{const t=e.fromBytes(o);if(a&&d.hasHighS())return!1;const{r:r,s:i}=d,s=P(n),c=f.inv(i),u=f.create(s*c),l=f.create(r*c),y=e.BASE.multiplyUnsafe(u).add(t.multiplyUnsafe(l));if(y.is0())return!1;return f.create(y.x)===r}catch(l){return!1}},recoverPublicKey:function(e,t,r={}){const{prehash:n}=h(r,T);return t=q(t,n),F.fromBytes(e,"recovered").recoverPublicKey(t).toBytes()},Signature:F,hash:t})}function I(e){const t={a:e.a,b:e.b,p:e.Fp.ORDER,n:e.n,h:e.h,Gx:e.Gx,Gy:e.Gy},r=e.Fp;let n=e.allowedPrivateKeyLengths?Array.from(new Set(e.allowedPrivateKeyLengths.map(e=>Math.ceil(e/2)))):void 0;return{CURVE:t,curveOpts:{Fp:r,Fn:(0,a.Field)(t.n,{BITS:e.nBitLength,allowedLengths:n,modFromBytes:e.wrapPrivateKey}),allowInfinityPoint:e.allowInfinityPoint,endo:e.endo,isTorsionFree:e.isTorsionFree,clearCofactor:e.clearCofactor,fromBytes:e.fromBytes,toBytes:e.toBytes}}}function A(e,t,r){return function(n){const o=e.sqr(n),i=e.mul(o,n);return e.add(e.add(i,e.mul(n,t)),r)}}}(a),Object.defineProperty(s,"__esModule",{value:!0}),s.getHash=function(e){return{hash:e}},s.createCurve=function(e,t){const r=t=>(0,J.weierstrass)({...e,hash:t});return{...r(t),create:r}};
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const J=a;var Q={};!function(e){Object.defineProperty(e,"__esModule",{value:!0}),e._DST_scalar=void 0,e.expand_message_xmd=u,e.expand_message_xof=d,e.hash_to_field=l,e.isogenyMap=function(e,t){const n=t.map(e=>Array.from(e).reverse());return(t,o)=>{const[i,s,a,c]=n.map(r=>r.reduce((r,n)=>e.add(e.mul(r,t),n))),[u,f]=(0,r.FpInvertBatch)(e,[s,c],!0);return t=e.mul(i,u),o=e.mul(o,e.mul(a,f)),{x:t,y:o}}},e.createHasher=function(t,r,n){if("function"!=typeof r)throw new Error("mapToCurve() must be defined");function o(e){return t.fromAffine(r(e))}function i(e){const r=e.clearCofactor();return r.equals(t.ZERO)?t.ZERO:(r.assertValidity(),r)}return{defaults:n,hashToCurve(e,t){const r=l(e,2,Object.assign({},n,t)),s=o(r[0]),a=o(r[1]);return i(s.add(a))},encodeToCurve(e,t){const r=n.encodeDST?{DST:n.encodeDST}:{};return i(o(l(e,1,Object.assign({},n,r,t))[0]))},mapToCurve(e){if(!Array.isArray(e))throw new Error("expected array of bigints");for(const t of e)if("bigint"!=typeof t)throw new Error("expected array of bigints");return i(o(e))},hashToScalar(r,o){const i=t.Fn.ORDER;return l(r,1,Object.assign({},n,{p:i,m:1,DST:e._DST_scalar},o))[0][0]}}};const t=c,r=f,n=t.bytesToNumberBE;function o(e,t){if(s(e),s(t),e<0||e>=1<<8*t)throw new Error("invalid I2OSP input: "+e);const r=Array.from({length:t}).fill(0);for(let n=t-1;n>=0;n--)r[n]=255&e,e>>>=8;return new Uint8Array(r)}function i(e,t){const r=new Uint8Array(e.length);for(let n=0;n<e.length;n++)r[n]=e[n]^t[n];return r}function s(e){if(!Number.isSafeInteger(e))throw new Error("number expected")}function a(e){if(!(0,t.isBytes)(e)&&"string"!=typeof e)throw new Error("DST must be Uint8Array or string");return"string"==typeof e?(0,t.utf8ToBytes)(e):e}function u(e,r,n,c){(0,t.abytes)(e),s(n),(r=a(r)).length>255&&(r=c((0,t.concatBytes)((0,t.utf8ToBytes)("H2C-OVERSIZE-DST-"),r)));const{outputLen:u,blockLen:f}=c,d=Math.ceil(n/u);if(n>65535||d>255)throw new Error("expand_message_xmd: invalid lenInBytes");const l=(0,t.concatBytes)(r,o(r.length,1)),y=o(0,f),h=o(n,2),b=new Array(d),m=c((0,t.concatBytes)(y,e,h,o(0,1),l));b[0]=c((0,t.concatBytes)(m,o(1,1),l));for(let s=1;s<=d;s++){const e=[i(m,b[s-1]),o(s+1,1),l];b[s]=c((0,t.concatBytes)(...e))}return(0,t.concatBytes)(...b).slice(0,n)}function d(e,r,n,i,c){if((0,t.abytes)(e),s(n),(r=a(r)).length>255){const e=Math.ceil(2*i/8);r=c.create({dkLen:e}).update((0,t.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(r).digest()}if(n>65535||r.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return c.create({dkLen:n}).update(e).update(o(n,2)).update(r).update(o(r.length,1)).digest()}function l(e,o,i){(0,t._validateObject)(i,{p:"bigint",m:"number",k:"number",hash:"function"});const{p:a,k:c,m:f,hash:l,expand:y,DST:h}=i;if(!(0,t.isHash)(i.hash))throw new Error("expected valid hash");(0,t.abytes)(e),s(o);const b=a.toString(2).length,m=Math.ceil((b+c)/8),p=o*f*m;let w;if("xmd"===y)w=u(e,h,p,l);else if("xof"===y)w=d(e,h,p,c,l);else{if("_internal_pass"!==y)throw new Error('expand must be "xmd" or "xof"');w=e}const g=new Array(o);for(let t=0;t<o;t++){const e=new Array(f);for(let o=0;o<f;o++){const i=m*(o+t*f),s=w.subarray(i,i+m);e[o]=(0,r.mod)(n(s),a)}g[t]=e}return g}e._DST_scalar=(0,t.utf8ToBytes)("HashToScalar-")}(Q),function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.encodeToCurve=t.hashToCurve=t.secp256k1_hasher=t.schnorr=t.secp256k1=void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const n=r,o=e,i=s,u=Q,d=f,l=a,y=c,h={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},b={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},m=BigInt(0),p=BigInt(1),w=BigInt(2);const g=(0,d.Field)(h.p,{sqrt:function(e){const t=h.p,r=BigInt(3),n=BigInt(6),o=BigInt(11),i=BigInt(22),s=BigInt(23),a=BigInt(44),c=BigInt(88),u=e*e*e%t,f=u*u*e%t,l=(0,d.pow2)(f,r,t)*f%t,y=(0,d.pow2)(l,r,t)*f%t,b=(0,d.pow2)(y,w,t)*u%t,m=(0,d.pow2)(b,o,t)*b%t,p=(0,d.pow2)(m,i,t)*m%t,E=(0,d.pow2)(p,a,t)*p%t,B=(0,d.pow2)(E,c,t)*E%t,v=(0,d.pow2)(B,a,t)*p%t,x=(0,d.pow2)(v,r,t)*f%t,O=(0,d.pow2)(x,s,t)*m%t,T=(0,d.pow2)(O,n,t)*u%t,S=(0,d.pow2)(T,w,t);if(!g.eql(g.sqr(S),e))throw new Error("Cannot find square root");return S}});t.secp256k1=(0,i.createCurve)({...h,Fp:g,lowS:!0,endo:b},n.sha256);const E={};function B(e,...t){let r=E[e];if(void 0===r){const t=(0,n.sha256)((0,y.utf8ToBytes)(e));r=(0,y.concatBytes)(t,t),E[e]=r}return(0,n.sha256)((0,y.concatBytes)(r,...t))}const v=e=>e.toBytes(!0).slice(1),x=(()=>t.secp256k1.Point)(),O=e=>e%w===m;function T(e){const{Fn:t,BASE:r}=x,n=(0,l._normFnElement)(t,e),o=r.multiply(n);return{scalar:O(o.y)?n:t.neg(n),bytes:v(o)}}function S(e){const t=g;if(!t.isValidNot0(e))throw new Error("invalid x: Fail if x â‰¥ p");const r=t.create(e*e),n=t.create(r*e+BigInt(7));let o=t.sqrt(n);O(o)||(o=t.neg(o));const i=x.fromAffine({x:e,y:o});return i.assertValidity(),i}const R=y.bytesToNumberBE;function I(...e){return x.Fn.create(R(B("BIP0340/challenge",...e)))}function A(e){return T(e).bytes}function F(e,t,r=(0,o.randomBytes)(32)){const{Fn:n}=x,i=(0,y.ensureBytes)("message",e),{bytes:s,scalar:a}=T(t),c=(0,y.ensureBytes)("auxRand",r,32),u=n.toBytes(a^R(B("BIP0340/aux",c))),f=B("BIP0340/nonce",u,s,i),{bytes:d,scalar:l}=T(f),h=I(d,s,i),b=new Uint8Array(64);if(b.set(d,0),b.set(n.toBytes(n.create(l+h*a)),32),!N(b,i,s))throw new Error("sign: Invalid signature produced");return b}function N(e,t,r){const{Fn:n,BASE:o}=x,i=(0,y.ensureBytes)("signature",e,64),s=(0,y.ensureBytes)("message",t),a=(0,y.ensureBytes)("publicKey",r,32);try{const e=S(R(a)),t=R(i.subarray(0,32));if(!(0,y.inRange)(t,p,h.p))return!1;const r=R(i.subarray(32,64));if(!(0,y.inRange)(r,p,h.n))return!1;const c=I(n.toBytes(t),v(e),s),u=o.multiplyUnsafe(r).add(e.multiplyUnsafe(n.neg(c))),{x:f,y:d}=u.toAffine();return!(u.is0()||!O(d)||f!==t)}catch(c){return!1}}t.schnorr=(()=>{const e=(e=(0,o.randomBytes)(48))=>(0,d.mapHashToField)(e,h.n);return t.secp256k1.utils.randomSecretKey,{keygen:function(t){const r=e(t);return{secretKey:r,publicKey:A(r)}},getPublicKey:A,sign:F,verify:N,Point:x,utils:{randomSecretKey:e,randomPrivateKey:e,taggedHash:B,lift_x:S,pointToBytes:v,numberToBytesBE:y.numberToBytesBE,bytesToNumberBE:y.bytesToNumberBE,mod:d.mod},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:48}}})();const P=(()=>(0,u.isogenyMap)(g,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(e=>e.map(e=>BigInt(e)))))(),_=(()=>(0,l.mapToCurveSimpleSWU)(g,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:g.create(BigInt("-11"))}))();t.secp256k1_hasher=(0,u.createHasher)(t.secp256k1.Point,e=>{const{x:t,y:r}=_(g.create(e[0]));return P(t,r)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:g.ORDER,m:1,k:128,expand:"xmd",hash:n.sha256}),t.hashToCurve=t.secp256k1_hasher.hashToCurve,t.encodeToCurve=t.secp256k1_hasher.encodeToCurve}(i);var ee={};Object.defineProperty(ee,"__esModule",{value:!0}),ee.isHash=ee.validateObject=ee.memoized=ee.notImplemented=ee.createHmacDrbg=ee.bitMask=ee.bitSet=ee.bitGet=ee.bitLen=ee.aInRange=ee.inRange=ee.asciiToBytes=ee.copyBytes=ee.equalBytes=ee.ensureBytes=ee.numberToVarBytesBE=ee.numberToBytesLE=ee.numberToBytesBE=ee.bytesToNumberLE=ee.bytesToNumberBE=ee.hexToNumber=ee.numberToHexUnpadded=ee.abool=ee.utf8ToBytes=ee.randomBytes=ee.isBytes=ee.hexToBytes=ee.concatBytes=ee.bytesToUtf8=ee.bytesToHex=ee.anumber=ee.abytes=void 0;const te=c;ee.abytes=te.abytes,ee.anumber=te.anumber,ee.bytesToHex=te.bytesToHex,ee.bytesToUtf8=te.bytesToUtf8,ee.concatBytes=te.concatBytes,ee.hexToBytes=te.hexToBytes,ee.isBytes=te.isBytes,ee.randomBytes=te.randomBytes,ee.utf8ToBytes=te.utf8ToBytes,ee.abool=te.abool,ee.numberToHexUnpadded=te.numberToHexUnpadded,ee.hexToNumber=te.hexToNumber,ee.bytesToNumberBE=te.bytesToNumberBE,ee.bytesToNumberLE=te.bytesToNumberLE,ee.numberToBytesBE=te.numberToBytesBE,ee.numberToBytesLE=te.numberToBytesLE,ee.numberToVarBytesBE=te.numberToVarBytesBE,ee.ensureBytes=te.ensureBytes,ee.equalBytes=te.equalBytes,ee.copyBytes=te.copyBytes,ee.asciiToBytes=te.asciiToBytes,ee.inRange=te.inRange,ee.aInRange=te.aInRange,ee.bitLen=te.bitLen,ee.bitGet=te.bitGet,ee.bitSet=te.bitSet,ee.bitMask=te.bitMask,ee.createHmacDrbg=te.createHmacDrbg,ee.notImplemented=te.notImplemented,ee.memoized=te.memoized,ee.validateObject=te.validateObject,ee.isHash=te.isHash;var re=i,ne=ee;function oe(e){var t=Object.create(null);return e&&Object.keys(e).forEach(function(r){if("default"!==r){var n=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,n.get?n:{enumerable:!0,get:function(){return e[r]}})}}),t.default=e,Object.freeze(t)}var ie=oe(f),se=oe(ne);const ae=re.secp256k1.ProjectivePoint,ce="Expected Private",ue="Expected Point",fe="Expected Tweak",de="Expected Signature",le="Expected Extra Data (32 bytes)",ye="Expected Scalar",he=new Uint8Array([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,186,174,220,230,175,72,160,59,191,210,94,140,208,54,65,65]),be=new Uint8Array(32),me=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,69,81,35,25,80,183,95,196,64,45,161,114,47,201,186,238]),pe=BigInt(1);function we(e,t){for(let r=0;r<32;++r)if(e[r]!==t[r])return e[r]<t[r]?-1:1;return 0}function ge(e){return 0===we(e,be)}function Ee(e){return e instanceof Uint8Array&&32===e.length&&!(we(e,he)>=0)}function Be(e){return e instanceof Uint8Array&&64===e.length&&we(e.subarray(0,32),he)<0&&we(e.subarray(32,64),he)<0}function ve(e){return e instanceof Uint8Array&&64===e.length&&we(e.subarray(0,32),me)<0}function xe(e){return e instanceof Uint8Array&&32===e.length}function Oe(e){return void 0===e||e instanceof Uint8Array&&32===e.length}function Te(e){let t;if("bigint"==typeof e)t=e;else if("number"==typeof e&&Number.isSafeInteger(e)&&e>=0)t=BigInt(e);else if("string"==typeof e){if(64!==e.length)throw new Error("Expected 32 bytes of private scalar");t=se.hexToNumber(e)}else{if(!(e instanceof Uint8Array))throw new TypeError("Expected valid private scalar");if(32!==e.length)throw new Error("Expected 32 bytes of private scalar");t=se.bytesToNumberBE(e)}if(t<0)throw new Error("Expected private scalar >= 0");return t}function Se(e){return re.secp256k1.utils.normPrivateKeyToScalar(e)}function Re(e,t,r){const n=Ne(e),o=Te(t),i=ae.BASE.multiplyAndAddUnsafe(n,o,pe);if(!i)throw new Error("Tweaked point at infinity");return i.toRawBytes(r)}function Ie(e,t){return void 0===e?void 0===t||Ue(t):!!e}function Ae(e){try{return e()}catch(t){return null}}function Fe(e){return re.schnorr.utils.lift_x(se.bytesToNumberBE(e))}function Ne(e){return 32===e.length?Fe(e):ae.fromHex(e)}function Pe(e,t){if(32===e.length!==t)return!1;try{return t?!!Fe(e):!!ae.fromHex(e)}catch(r){return!1}}function _e(e){return Pe(e,!1)}function Ue(e){return Pe(e,!1)&&33===e.length}function qe(e){return re.secp256k1.utils.isValidPrivateKey(e)}function ke(e){return Pe(e,!0)}function je(e){if(!_e(e))throw new Error(ue);return e.slice(1,33)}function Ce(e,t){if(!qe(e))throw new Error(ce);return Ae(()=>re.secp256k1.getPublicKey(e,Ie(t)))}var De=o.isPoint=_e,He=o.isPointCompressed=Ue,Ve=o.isPrivate=qe,Le=o.isXOnlyPoint=ke,Ze=o.pointAdd=function(e,t,r){if(!_e(e)||!_e(t))throw new Error(ue);return Ae(()=>{const n=Ne(e),o=Ne(t);return n.equals(o.negate())?null:n.add(o).toRawBytes(Ie(r,e))})},Ke=o.pointAddScalar=function(e,t,r){if(!_e(e))throw new Error(ue);if(!Ee(t))throw new Error(fe);return Ae(()=>Re(e,t,Ie(r,e)))},Me=o.pointCompress=function(e,t){if(!_e(e))throw new Error(ue);return Ne(e).toRawBytes(Ie(t,e))},ze=o.pointFromScalar=Ce,$e=o.pointMultiply=function(e,t,r){if(!_e(e))throw new Error(ue);if(!Ee(t))throw new Error(fe);return Ae(()=>function(e,t,r){const n=Ne(e),o="string"==typeof t?t:se.bytesToHex(t),i=se.hexToNumber(o);return n.multiply(i).toRawBytes(r)}(e,t,Ie(r,e)))},Ye=o.privateAdd=function(e,t){if(!qe(e))throw new Error(ce);if(!Ee(t))throw new Error(fe);return Ae(()=>function(e,t){const r=Se(e),n=Te(t),o=se.numberToBytesBE(ie.mod(r+n,re.secp256k1.CURVE.n),32);return re.secp256k1.utils.isValidPrivateKey(o)?o:null}(e,t))},Ge=o.privateNegate=function(e){if(!qe(e))throw new Error(ce);return function(e){const t=Se(e),r=se.numberToBytesBE(re.secp256k1.CURVE.n-t,32);return re.secp256k1.utils.isValidPrivateKey(r)?r:null}(e)},Xe=o.privateSub=function(e,t){if(!qe(e))throw new Error(ce);if(!Ee(t))throw new Error(fe);return Ae(()=>function(e,t){const r=Se(e),n=Te(t),o=se.numberToBytesBE(ie.mod(r-n,re.secp256k1.CURVE.n),32);return re.secp256k1.utils.isValidPrivateKey(o)?o:null}(e,t))},We=o.recover=function(e,t,r,n){if(!xe(e))throw new Error("Expected Hash");if(!Be(t)||!function(e){return!(ge(e.subarray(0,32))||ge(e.subarray(32,64)))}(t))throw new Error(de);if(2&r&&!ve(t))throw new Error("Bad Recovery Id");if(!ke(t.subarray(0,32)))throw new Error(de);const o=re.secp256k1.Signature.fromCompact(t).addRecoveryBit(r).recoverPublicKey(e);if(!o)throw new Error(de);return o.toRawBytes(Ie(n))},Je=o.sign=function(e,t,r){if(!qe(t))throw new Error(ce);if(!xe(e))throw new Error(ye);if(!Oe(r))throw new Error(le);return re.secp256k1.sign(e,t,{extraEntropy:r}).toCompactRawBytes()},Qe=o.signRecoverable=function(e,t,r){if(!qe(t))throw new Error(ce);if(!xe(e))throw new Error(ye);if(!Oe(r))throw new Error(le);const n=re.secp256k1.sign(e,t,{extraEntropy:r});return{signature:n.toCompactRawBytes(),recoveryId:n.recovery}},et=o.signSchnorr=function(e,t,r){if(!qe(t))throw new Error(ce);if(!xe(e))throw new Error(ye);if(!Oe(r))throw new Error(le);return re.schnorr.sign(e,t,r)},tt=o.verify=function(e,t,r,n){if(!_e(t))throw new Error(ue);if(!Be(r))throw new Error(de);if(!xe(e))throw new Error(ye);return re.secp256k1.verify(r,e,t,{lowS:n})},rt=o.verifySchnorr=function(e,t,r){if(!ke(t))throw new Error(ue);if(!Be(r))throw new Error(de);if(!xe(e))throw new Error(ye);return re.schnorr.verify(r,e,t)},nt=o.xOnlyPointAddTweak=function(e,t){if(!ke(e))throw new Error(ue);if(!Ee(t))throw new Error(fe);return Ae(()=>{const r=Re(e,t,!0);return{parity:r[0]%2==1?1:0,xOnlyPubkey:r.slice(1)}})},ot=o.xOnlyPointFromPoint=je,it=o.xOnlyPointFromScalar=function(e){if(!qe(e))throw new Error(ce);return je(Ce(e))};const st=n({__proto__:null,default:o,isPoint:De,isPointCompressed:He,isPrivate:Ve,isXOnlyPoint:Le,pointAdd:Ze,pointAddScalar:Ke,pointCompress:Me,pointFromScalar:ze,pointMultiply:$e,privateAdd:Ye,privateNegate:Ge,privateSub:Xe,recover:We,sign:Je,signRecoverable:Qe,signSchnorr:et,verify:tt,verifySchnorr:rt,xOnlyPointAddTweak:nt,xOnlyPointFromPoint:ot,xOnlyPointFromScalar:it},[o]);export{st as i};
